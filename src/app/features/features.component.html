<div class="container">

    <p>1. Angular Elements
        Angular is a perfect framework for developing Single Page Applications. To create a widget or component that can be included in any existing web page, was not a simple task in earlier versions of Angular. But in Angular 6, it can be done with the help of Angular Elements. Actually, Angular 6 is the first Angular release which completely supports Angular Elements. Angular Elements is the brainchild of Angular’s Rob Wormald. The Angular Elements package will give us the ability to create an Angular component and then publish that component as a web component which can be used in any HTML page (even if that page is not using the Angular framework) in other environments. It actually takes an Angular component and then wraps it within a custom element, such as a DOM element, so that we can use our favorite Angular component in other projects which do not use Angular.
        
        2. Service Worker Support
        Service workers are basically scripts which run in the web browser and manage to cache an application. Service workers were first introduced in Angular 5. In Angular 6, service workers come with some bug fixes, including some new functionalities. So when we deploy the latest version of the application, we may need to deactivate or uninstall the existing service worker(s). In Angular 5, there is no straightforward option for doing this, but Angular 6 brings this functionality with the new script file named safety-worker.js, which is actually a part of the production bundle which helps us to unregister the existing service worker(s).
        
        Angular 6 now supports the configuration of navigation URLs within the Service Workers. The service worker will redirect navigation requests that don’t match any source or data group to the specified index file. Now, we can mention an optional navigationUrls list in ngsw-config.json files which contain the desired URLs. If, for example, a request's URLs match any of the positive patterns and none of the navigate patterns, then it will be considered a navigation request and handled the right way by the service worker. In Angular 6, the service worker remains in the current mode unless the server is reconnected and updates the work.
        
        3. Bye, Bye Template Element
        The element was depreciated one year ago when Angular 4 was launched. Now it’s time to say goodbye to because it is now removed from Angular 6 framework. Instead of using , we now need to use .
        
        4. i18n
        One of the major changes in Angular 6 is internationalization or i18n. In Angular 6, i18n is coming with runtime rendering so that there is no requirement to build one application per locale. The currency pipe was improved in Angular 6 in such a that it makes a lot of sense, for example, it will not round every currency value with 2 digits anymore. It will then round the currency to the appropriate digits (like it can be 3 digit roundup for Arabic Dinar or 0 roundup for Chilean Pesos). If we want to retrieve these values programmatically, then we need to use the i18n function getNumberOfCurrencyDigits(). There are some other formatting functions which are also exposed publicly like formatDate, formatCurrency, formatPercent, and formatNumber.
        
        5. Ivy: New Rendering Engine
        In Angular 6, the Angular team introduced their third rendering engine called Ivy. Ivy is the next generation Angular rendering engine. In some of the previous versions of Angular (i.e. Angular 2 to Angular 4), Angular used a view engine for rendering purposes. The introduction of this rendering engine experience increases the speed and decreases the size of the application. The Angular team expects the same type of experience with the new rendering engine.
        
        Angular compiles our templates into equivalent TypeScript code and then that TypeScript code is compiled to JavaScript and then the result is shipped to our users.  So Ivy renderer is the new rendering engine which is basically designed to support backward compatibility with existing renderers and then also focused to improve the speed of rendering and it also optimized the size of the final package. In Angular, it will not be the default renderer but we can manually enable it using the compiler options. This important feature is not completely released in Angular 6 since it is in experimental mode; except the complete version in Angular's next release.
        
        6. ngModelChange
        Before Angular 6, the ngModelChange event was emitted before the said form control updating. If we have an event handler for the ngModelChange event that checked the value through the control, the old value will be returned instead of the changed value. Now, in Angular 6, ngModelChange has emitted the value after the value is updated in the form control.
        
        7. ElementRef
        In previous versions of Angular, when we want to create the reference of an element in the template, we can use @ViewChild or @ViewChildren or inject the host using ElementRef directly. But, the problem is that ElementRef had its nativeElement property typed like any other element. But now in Angular 6, we can use type ElementRef more strictly if we want.</p>
</div>
